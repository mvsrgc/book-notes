## Operating System Concepts

### Chapter 9: Main Memory
* **9.1.1 Basic Hardware**
	* Main memory and registers are the only general-storage the CPU can access.
	* Registers are generally available within 1 cycle of the CPU clock.
	* We must protect the operating system from access by user processes, as well as
	  protect user processes from one another. (This protection has to be implemented
	  by the hardware because the OS does not usually intervene between the CPU and it's
	  memory accesses.)
	* To achieve this, we need to ensure that each process has a separate memory space.
	  To do so, we need to determine the range of addresses that the process may access.
	  This is done by using two registers: a *base*, and a *limit*. *limit* specifies the
	  size of the range. (Manipulating these registers can only be done in kernel mode.)
* **9.1.2 Address Binding**
	* Addresses in source programs are generally symbolic. A compiler *binds* these addresses
	  to relocatable addresses. (such as "14 bytes from the beginning of this module")
	* The linker in turn binds the relocatable addresses to absolute addresses.
	* CPU (Logical address) -> Memory management unit (Physical address) -> Physical memory
	* The logical address is usually referred to as *virtual address*.
* **9.2.2 Memory Allocation**
	* First fit: Allocate the first hole that is big enough.
	* Best fit: Allocate the *smallest* hole that is big enough. Produces *smallest* leftover hole.
	* Worst fit: Allocate the largest hole. Produces *largest* leftover hole.
	* Simulations have shown that first fit and best fit are better than worst fit for decreasing
	  time and storage utilization.
	* Neither first fit or best fit are better than the other, but first fit is generally faster.
	* *First fit* and *best fit* both suffer from *external* memory fragmentation. As processes are
	  loaded and removed, the free memory space is broken into little pieces.
	* *External fragmentation*: There is enough total memory space to satisfy a request but the available
	  spaces are not contiguous: storage is fragmented into a large number of small holes.
	* A solution to external fragmentation is called *paging*, this is the concept of permitting
	  the logical address space of processes to be noncontiguous.
* **9.3.1 Basic Paging Method**
	* | Memory Unit | Description                                 | Memory Type        |
	  |-------------|---------------------------------------------|--------------------|
	  | Frames      | Fixed-size blocks                           | Physical Memory    |
	  | Pages       | Fixed-size blocks                           | Logical Memory     |
	* Translating a logical address generated by the CPU to a physical address
		* Logical address: |page number \(p\) | page offset (d)|
		* 1) Extract the page number *p* and use it as an index into the page table.
	      2) Extract the corresponding frame number *f* from the page table.
		  3) Replace the page number *p* in the logical address with the frame number *f*.
	* A process is not able to access memory it does not own. It has no way of addressing memory outside of its page table,
	  and the table includes only those pages that the process owns. (Being able to access another process's page table
	  may be known as a priviledge escalation vulnerability.)
* **9.3.2 Hardware Support**
	* A pointer to the page table is stored with the other register values (like the instruction pointer.) (Because page tables
	  are per-process.)
	* The page table is kept in main memory, and a page-table base register (PTBR) points to the page table.
	* If we only had the PTBR and the page table in memory, memory access is slowed by a factor of 2.
	* With a PTB, we can calculate effective access time by multiplying the hit ratio by:

	  $accesTime * hitRatio + (1 - hitRatio) * (accessTime * 2)$.

	  Example: Hit ratio is 80%, it takes 10 nanoseconds to access memory, eff. access time: 
	  
	  $0.80 * 10 + 0.20 * 20 = 12$ nanoseconds
* **9.3.4 Share Pages**
	* Pages can be shared. Otherwise if 40 processes needed to use libc and the library is 2MB this would require 80MB of memory.
	* The code has to be reentrant (non-self-modifying code which never changes during execution)
	* The read-only nature of shared code should be enforced by the operating system.
* **9.4.1 Hierarchical Paging**
	* We use hierarchical paging because otherwise each process would have to hold the entire page table in memory.
	  (For a system with a 32-bit logical address space, and a page size of 4KB, this is 2^20 entries in the page table and at 4 bytes each it's over
	  4MB of memory)
